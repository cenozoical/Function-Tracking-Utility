The goal of this project was designing and implemening a utility which would trace execution time of a specified Python functions. The entirety of the function tracing utility is implemented inside the 'functionTracking.py' script. The other script is made from the perspective of user of that utility and it demonstrates how to use it.
In order to start the utility it is enough to import the 'functionTracking.py' utility ("from functionTracking import *"). Functions that are to be tracked can be marked using the '@TrackExecutionTime' decorator('@TrackLifetime' would be a more precise name, since the utility measures the time elapsed from each function call) . Note that, as consequence of using decorators, for the utility to register a function, at least one call to that decorated function needs to occur.
User can communicate with the utility using the command line interface: the utility hijacks the input function from the user application and redirects calls to it to a blocking queue. It then analyses each input line, and if it doesn't recognize one of the pre-defined commands, it passes it to that queue. Commands which it accepts are: '$display' (prints the information about all the registered functions which are currently being profiled), '$toogleOn [funName]' (enables profiling for the function 'funName'), '$toogleOff [funName]' (it is possible to toogle off profiling for the function which has not yet been register, so caution is advised when typing functions name), '$toogleAllOn', '$toogleAllOff', '$exit'(permanently stops function tracing utility). The application that uses this utility doesn't end until utility has been terminated.
Finally, the implemented utility provides support for multithreaded applications.


**Note: if the table is not displaying well, try viewing it in full screen.
